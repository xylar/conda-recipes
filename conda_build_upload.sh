#!/bin/sh -x

PKG_NAME=$1
WORKDIR=$2
UPLOAD_LABEL=$3
USER=cdat

#
# Arguments:
#    + WORKDIR - work directory where this script can write information to.
#
# Requirements:
#    + conda is installed, and added to PATH
#    + this script should be run on a repo top directory where 'recipe' directory resides
#    + this script assumes prep_for_build.py has been run on the repo directory and  
#      recipe/meta.yaml is generated.
#

source activate base
if [ `uname` == "Linux" ]; then
    OS=linux-64
else
    OS=osx-64
fi

if [ ! -d $WORKDIR ]; then
    mkdir $WORKDIR
fi

BASE_DIR=$(dirname "$0")
echo "BASE_DIR: $BASE_DIR"

prep_conda_env()
{
    conda clean --all
    conda install -n base -c conda-forge conda-build anaconda conda-smithy conda-verify
    conda update -y -q conda
    conda config --set anaconda_upload no
}

copy_repo_recipe()
{
    # copy project recipe to workdir
    cp -r $REPO_DIR/recipe $WORKDIR
}

get_conda_forge_configs() 
{
    # copy build configs from conda-forge to workdir

    # get conda_build_config.yaml -- this file defines the versions of 
    # globally pinned packages.
    url="https://www.github.com/conda-forge/conda-forge-pinning-feedstock.git"
    git clone $url $WORKDIR/conda-forge-pinning-feedstock
    cd $WORKDIR/conda-forge-pinning-feedstock
    git checkout c3714e1513b62240fb517067c9ba8eb0485ef7a7
    cp $WORKDIR/conda-forge-pinning-feedstock/recipe/conda_build_config.yaml $WORKDIR/recipe
    echo "xxx cat $WORKDIR/recipe/conda_build_config.yaml"
    cat $WORKDIR/recipe/conda_build_config.yaml
    # get the migrations folder
    cp -r $WORKDIR/conda-forge-pinning-feedstock/recipe/migrations $WORKDIR/recipe

    if [[ ! -d $WORKDIR/.ci_support ]]; then
	echo "XXX mkdir $WORKDIR/.ci_support"
	mkdir $WORKDIR/.ci_support
    fi
    cd $WORKDIR
    echo "XXX conda smithy rerender"
    conda smithy rerender
    
}

copy_build_yaml_to_repo()
{
    # copy yaml's (configuration files)  generated by rerender 
    # back to repo directory.
    echo "XXX copy_build_yaml_to_repo XXX"
    if [[ ! -d $REPO_DIR/.ci_support ]]; then
	mkdir $REPO_DIR/.ci_support
	echo "xxx mkdir $REPO_DIR/.ci_support"
    fi
    cp -r $WORKDIR/.ci_support/* $REPO_DIR/.ci_support
    echo "xxx ls -al $REPO_DIR/.ci_support"
    ls -al $REPO_DIR/.ci_support
}

#
# here, if needed, we can specify --variants "{'python': ['2.7', '3.7']}"
#
do_build()
{
    cd $REPO_DIR
    mkdir conda-bld
    export CONDA_BLD_PATH=conda-bld
    echo "XXX ls -al $REPO_DIR"
    ls -al $REPO_DIR
    echo "XXX ls -al $REPO_DIR/.ci_support"
    ls -l $REPO_DIR/.ci_support
    # conda build recipe
    if [ $OS == 'linux-64' ]; then
	for x in $(ls .ci_support/linux*yaml); do
            echo "XXX cat ${x}"
	    cat ${x}
	    echo "conda build $PKG_NAME -m ${x} -c conda-forge"
	    conda build -m ${x} -c conda-forge recipe
	done
    else
	for x in $(ls .ci_support/osx*yaml); do
            echo "XXX cat ${x}"
	    cat ${x}
	    echo "conda build $PKG_NAME -m ${x} -c conda-forge"
	    conda build -m ${x} -c conda-forge recipe
	done
    fi
}

do_upload()
{
    echo "xxx xxx CONDA_BLD_PATH: $CONDA_BLD_PATH"
    echo "xxx xxx PKG_NAME: $PKG_NAME"
    echo "xxx xxx VERSION: $VERSION"

    if [[ $UPLOAD_LABEL = 'DO_NOT_UPLOAD' ]]; then
        return
    fi
    grep noarch recipe/meta.yaml.in 2>&1 > /dev/null
    if [[ $? = 0 ]]; then
	# noarch
	echo "CMD: anaconda -t $CONDA_UPLOAD_TOKEN upload -u $USER -l $LABEL $CONDA_BLD_PATH/noarch/$PKG_NAME-$VERSION.`date +%Y*`0.tar.bz2 --force"
	anaconda -t $CONDA_UPLOAD_TOKEN upload -u $USER -l $LABEL $CONDA_BLD_PATH/noarch/$PKG_NAME-$VERSION.`date +%Y*`0.tar.bz2 --force
    else
	# not noarch
	echo "CMD: anaconda -t $CONDA_UPLOAD_TOKEN upload -u $USER -l $LABEL $CONDA_BLD_PATH/$OS/${PKG_NAME}-$VERSION.`date +%Y*`0.tar.bz2 --force"
	anaconda -t $CONDA_UPLOAD_TOKEN upload -u $USER -l $LABEL $CONDA_BLD_PATH/$OS/${PKG_NAME}-$VERSION.`date +%Y*`0.tar.bz2 --force
    fi
    
}

REPO_DIR=`pwd`
echo "REPO_DIR: $REPO_DIR"

prep_conda_env

copy_repo_recipe

get_conda_forge_configs

##conda smithy rerender

copy_build_yaml_to_repo

do_build

do_upload
